Index: CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>cmake_minimum_required(VERSION 3.13)\r\nproject(net_simulation)\r\n\r\nset(CMAKE_CXX_STANDARD 17)\r\nadd_compile_options(-Wall -Wextra -Werror -Wpedantic -pedantic-errors -Werror=switch)\r\n\r\ninclude_directories(include)\r\nset(SOURCE_FILES src/package.cpp src/storage_types.cpp\r\n        src/nodes.cpp src/helpers.cpp src/factory.cpp src/reports.cpp)\r\nadd_executable(netsim ${SOURCE_FILES} main.cpp)\r\n\r\n# == Unit testing using Google Testing Framework ==\r\n\r\n# Ustaw zmienną `SOURCES_FILES_TESTS`, która będzie przechowywać ścieżki do\r\n# plików źródłowych z testami jednostkowymi.\r\nset(SOURCES_FILES_TESTS\r\n        test/test/nodes_test.cpp\r\n        test/test/test_Factory.cpp\r\n        test/test/test_nodes.cpp\r\n        test/test/test_package.cpp\r\n        test/test/test_storage_types.cpp\r\n\r\n        test/test/test_factory_io.cpp\r\n        test/test/test_reports.cpp\r\n        #test/test/test_simulate.cpp\r\n        )\r\n\r\n# Dodaj konfigurację typu `Test`.\r\nadd_executable(netsim_test ${SOURCE_FILES} ${SOURCES_FILES_TESTS} test/test/main_gtest.cpp)\r\n\r\n# Dodaj katalogi z plikami nagłówkowymi wyłącznie do konkretnej konfiguracji (tu: `Test`).\r\ntarget_include_directories(netsim_test PUBLIC\r\n        googletest-master/googlemock/include\r\n        googletest-master/googletest/include\r\n        test/mocks\r\n        )\r\n\r\n# Dodaj podkatalog `googletest-master`.\r\nadd_subdirectory(googletest-master)\r\n\r\n# Podlinkuj bibliotekę o identyfikatorze `gmock` (w pliku CMake) wyłącznie do konkretnej\r\n# konfiguracji (tu: `Test`).\r\ntarget_link_libraries(netsim_test gmock)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	(revision 7a8cf0f2fd37946f75c7cfb35e50dc4fcc662300)
+++ b/CMakeLists.txt	(date 1611008380731)
@@ -22,7 +22,7 @@
 
         test/test/test_factory_io.cpp
         test/test/test_reports.cpp
-        #test/test/test_simulate.cpp
+        test/test/test_simulate.cpp
         )
 
 # Dodaj konfigurację typu `Test`.
Index: src/factory.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// 35: Rafa (401991) Szota(401281)  Lenarczyk(402763)\r\n\r\n#include \"factory.hpp\"\r\n#include \"cassert\"\r\n\r\n\r\nvoid Factory::add_ramp(Ramp && new_ramp)\r\n{\r\n    Ramps.add_node(std::move(new_ramp));\r\n}\r\n\r\nvoid Factory::remove_ramp(ElementID id)\r\n{\r\n    Ramps.remove_by_id(id);\r\n}\r\n\r\nNodeCollection<Ramp>::iterator Factory::find_ramp_by_id(ElementID id)\r\n{\r\n    NodeCollection<Ramp>::iterator it;\r\n    for (it = Ramps.begin(); it != Ramps.end(); ++it){\r\n        if(it->get_id() == id)\r\n            return it;\r\n    }\r\n    //Pętla powinna znaleźć odpowiednii element\r\n    assert(false);\r\n    return Ramps.end();\r\n\r\n    Ramps.\r\n}\r\n\r\nNodeCollection<Ramp>::const_iterator Factory::find_ramp_by_id(ElementID id) const\r\n{\r\n    NodeCollection<Ramp>::const_iterator it;\r\n    for (it = Ramps.cbegin(); it != Ramps.cend(); ++it){\r\n        if(it->get_id() == id)\r\n            return it;\r\n    }\r\n    //Pętla powinna znaleźć odpowiednii element\r\n    assert(false);\r\n    return Ramps.cend();\r\n}\r\n\r\nNodeCollection<Ramp>::const_iterator Factory::ramp_cbegin() const\r\n{\r\n    return  Ramps.cbegin();\r\n}\r\n\r\nNodeCollection<Ramp>::const_iterator Factory::ramp_cend() const\r\n{\r\n    return Ramps.cend();\r\n}\r\n\r\nvoid Factory::add_worker(Worker && new_worker)\r\n{\r\n    Workers.add_node(std::move(new_worker));\r\n}\r\n\r\nvoid Factory::remove_worker(ElementID id)\r\n{\r\n    remove_receiver(Workers,id);\r\n    remove_receiver(Ramps,id);\r\n\r\n    Workers.remove_by_id(id);\r\n}\r\n\r\nNodeCollection<Worker>::iterator Factory::find_worker_by_id(ElementID id)\r\n{\r\n    NodeCollection<Worker>::iterator it;\r\n    for (it = Workers.begin(); it != Workers.end(); ++it){\r\n        if( it->get_id() == id )\r\n            return it;\r\n    }\r\n    //Pętla powinna znaleźć odpowiednii element\r\n    assert(false);\r\n    return Workers.end();\r\n}\r\n\r\nNodeCollection<Worker>::const_iterator Factory::find_worker_by_id(ElementID id) const\r\n{\r\n    NodeCollection<Worker>::const_iterator it;\r\n    for (it = Workers.cbegin(); it != Workers.cend(); ++it){\r\n        if( it->get_id() == id )\r\n            return it;\r\n    }\r\n    //Pętla powinna znaleźć odpowiednii element\r\n    assert(false);\r\n    return Workers.cend();\r\n}\r\n\r\nNodeCollection<Worker>::const_iterator Factory::worker_cbegin() const\r\n{\r\n    return Workers.cbegin();\r\n}\r\n\r\nNodeCollection<Worker>::const_iterator Factory::worker_cend() const\r\n{\r\n    return Workers.cend();\r\n}\r\n\r\nvoid Factory::add_storehouse(Storehouse && new_Storehouse)\r\n{\r\n    Storehouses.add_node(std::move(new_Storehouse));\r\n}\r\n\r\nvoid Factory::remove_storehouse(ElementID id)\r\n{\r\n    remove_receiver(Workers,id);\r\n\r\n    Storehouses.remove_by_id(id);\r\n}\r\n\r\nNodeCollection<Storehouse>::iterator Factory::find_storehouse_by_id(ElementID id)\r\n{\r\n    NodeCollection<Storehouse>::iterator it;\r\n    for (it = Storehouses.begin(); it != Storehouses.end(); ++it){\r\n        if( it->get_id() == id )\r\n            return it;\r\n    }\r\n    //Pętla powinna znaleźć odpowiednii element\r\n    assert(false);\r\n    return Storehouses.end();\r\n}\r\n\r\nNodeCollection<Storehouse>::const_iterator Factory::find_storehouse_by_id(ElementID id) const\r\n{\r\n    NodeCollection<Storehouse>::const_iterator it;\r\n    for (it = Storehouses.cbegin(); it != Storehouses.cend(); ++it){\r\n        if( it->get_id() == id )\r\n            return it;\r\n    }\r\n    //Pętla powinna znaleźć odpowiednii element\r\n    assert(false);\r\n    return Storehouses.cend();\r\n}\r\n\r\nNodeCollection<Storehouse>::const_iterator Factory::storehouse_cbegin() const\r\n{\r\n    return Storehouses.cbegin();\r\n}\r\n\r\nNodeCollection<Storehouse>::const_iterator Factory::storehouse_cend() const\r\n{\r\n    return Storehouses.cend();\r\n}\r\n\r\nbool Factory::is_consistent() const\r\n{\r\n    std::map<const PackageSender *, NodeColor> dictionary;\r\n    // Zmiana stanu wszystkich Ramp i pracowników na nieodwiedzonych\r\n    for(auto &ramp:Ramps)\r\n    {\r\n        auto* PSend_ptr = (PackageSender *) &ramp;\r\n        dictionary[ PSend_ptr ] = NodeColor::UNVISITED;\r\n    }\r\n    for(auto &worker:Workers)\r\n    {\r\n        auto* PSend_ptr = (PackageSender *) &worker;\r\n        dictionary[ PSend_ptr ] = NodeColor::UNVISITED;\r\n    }\r\n\r\n    for(auto &ramp:Ramps)\r\n    {\r\n        try{\r\n            has_reachable_storehouse(&ramp,dictionary);\r\n        } catch (std::logic_error &) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nbool Factory::has_reachable_storehouse(const PackageSender *sender,\r\n                                       std::map<const PackageSender *,\r\n                                       NodeColor> &node_colors) const{\r\n\r\n    if(node_colors[sender] == NodeColor::VERIFIED)\r\n        return true;\r\n    node_colors[sender] =NodeColor::VISITED;\r\n    if(sender->receiver_preferences_.get_preferences().empty())\r\n    {\r\n        // Wyrzucenie wyjątku\r\n        throw std::logic_error(\"Element nie ma odbiorcow\");\r\n    }\r\n    bool sender_have_reciver = false;\r\n\r\n    for(auto &reciver_p : sender->receiver_preferences_.get_preferences())\r\n    {\r\n        if(reciver_p.first->get_receiver_type() == ReceiverType::STOREHOUSE)\r\n            sender_have_reciver = true;\r\n        else if(reciver_p.first->get_receiver_type() == ReceiverType::WORKER)\r\n        {\r\n            // Konwersja reciver na sender ( bo wiadomo, że mamy do czynienia z Worker):\r\n            IPackageReceiver* receiver_ptr = reciver_p.first;\r\n            auto worker_ptr = dynamic_cast<Worker*>(receiver_ptr);\r\n            auto sendrecv_ptr = dynamic_cast<PackageSender*>(worker_ptr);\r\n\r\n            if(sendrecv_ptr == sender)\r\n            {\r\n                continue; // Przejście do kolejnego odbiorcy\r\n            }\r\n            sender_have_reciver = true;\r\n            if(node_colors[sendrecv_ptr] == NodeColor::UNVISITED)\r\n                has_reachable_storehouse(sendrecv_ptr,node_colors);\r\n        }\r\n    }\r\n    node_colors[sender] = NodeColor::VERIFIED;\r\n    if(sender_have_reciver)\r\n        return true;\r\n    else\r\n        // Wyrzucenie wyjątku\r\n        throw std::logic_error(\"Element nie ma prawidłowych odbiorcow\");\r\n}\r\n\r\n\r\nvoid Factory::do_deliveries(Time t) {\r\n    for(auto it = Ramps.begin(); it != Ramps.end(); it++){\r\n        it->deliver_goods(t);\r\n    }\r\n}\r\n\r\nvoid Factory::do_package_passing() {\r\n    for(auto it = Ramps.begin(); it != Ramps.end(); it++){\r\n        it->send_package();\r\n    }\r\n    for(auto it = Workers.begin(); it != Workers.end(); it++){\r\n        it->send_package();\r\n    }\r\n}\r\n\r\nvoid Factory::do_work(Time t) {\r\n    for(auto it = Workers.begin(); it != Workers.end(); it++){\r\n        it->do_work(t);\r\n    }\r\n}\r\n\r\n/// Wczytywanie i zapis stanu fabryki\r\n\r\nFactory load_factory_structure(std::istream& is)\r\n{\r\n    //std::unique_ptr<Factory> factory = std::make_unique<Factory>();\r\n    Factory factory;\r\n\r\n    std::string line;\r\n\r\n    while (std::getline(is, line)) {\r\n        if(line.empty() or line.front() == ';')\r\n        {\r\n            continue;\r\n        }\r\n        ParsedLineData new_el = parse_line(line);\r\n\r\n        if(new_el.element_type == ElementType::RAMP)\r\n        {\r\n            int id = std::stoi( new_el.parameters.find(\"id\")->second );\r\n            int delivery_interval = std::stoi( new_el.parameters.find(\"delivery-interval\")->second );\r\n\r\n            factory.add_ramp(Ramp(id,delivery_interval));\r\n        } else if(new_el.element_type == ElementType::WORKER){\r\n            int id = std::stoi( new_el.parameters.find(\"id\")->second );\r\n            int processing_time = std::stoi( new_el.parameters.find(\"processing-time\")->second );\r\n\r\n            PackageQueueType queue_type;\r\n            if(new_el.parameters.find(\"queue-type\")->second == \"LIFO\")\r\n                queue_type = PackageQueueType::LIFO;\r\n            else if(new_el.parameters.find(\"queue-type\")->second == \"FIFO\")\r\n                queue_type = PackageQueueType::FIFO;\r\n            else\r\n                throw std::logic_error(\"Nie znaleziono właściwego typu kolejki\");\r\n\r\n            factory.add_worker(Worker(id,processing_time,std::make_unique<PackageQueue>(queue_type)));\r\n        } else if(new_el.element_type == ElementType::STOREHOUSE) {\r\n            int id = std::stoi(new_el.parameters.find(\"id\")->second);\r\n            factory.add_storehouse(Storehouse(id));\r\n        } else if(new_el.element_type == ElementType::LINK)\r\n        {\r\n            ElementType src_type;\r\n            ElementType dest_type;\r\n\r\n            ElementID src_id;\r\n            ElementID dest_id;\r\n\r\n            std::string src_str;\r\n            std::string dest_str;\r\n\r\n            src_str = new_el.parameters[\"src\"];\r\n            dest_str = new_el.parameters[\"dest\"];\r\n\r\n            std::size_t pause_pos_s = src_str.find('-');\r\n            std::string src_type_str = src_str.substr(0,pause_pos_s);\r\n            src_type = get_el_type_small(src_type_str);\r\n            src_id = std::stoi( src_str.substr(pause_pos_s +1 ) );\r\n\r\n            std::size_t pause_pos_d = dest_str.find('-');\r\n            std::string dest_type_str = dest_str.substr(0,pause_pos_d);\r\n            dest_type = get_el_type_small(dest_type_str);\r\n            dest_id = std::stoi(dest_str.substr(pause_pos_d + 1));\r\n\r\n            if(src_type == ElementType::RAMP)\r\n            {\r\n                if(dest_type == ElementType::WORKER)\r\n                {\r\n                    factory.find_ramp_by_id(src_id)->receiver_preferences_.add_receiver(&(*(factory.find_worker_by_id(dest_id))));\r\n                }else if(dest_type == ElementType::STOREHOUSE)\r\n                {\r\n                    factory.find_ramp_by_id(src_id)->receiver_preferences_.add_receiver(&(*(factory.find_storehouse_by_id(dest_id))));\r\n                }else\r\n                {\r\n                    throw std::logic_error(\"Nieprawidłowy typ ElementType dla dest\");\r\n                }\r\n\r\n            }else if(src_type == ElementType::WORKER)\r\n            {\r\n                if(dest_type == ElementType::WORKER)\r\n                {\r\n                    factory.find_worker_by_id(src_id)->receiver_preferences_.add_receiver(&(*(factory.find_worker_by_id(dest_id))));\r\n                }else if(dest_type == ElementType::STOREHOUSE)\r\n                {\r\n                    factory.find_worker_by_id(src_id)->receiver_preferences_.add_receiver(&(*(factory.find_storehouse_by_id(dest_id))));\r\n                }else\r\n                {\r\n                    throw std::logic_error(\"Nieprawidłowy typ ElementType dla dest\");\r\n                }\r\n            }else\r\n            {\r\n                throw std::logic_error(\"Nieprawidłowy typ ElementType dla src\");\r\n            }\r\n\r\n        }\r\n    }\r\n    return factory;\r\n}\r\n\r\nParsedLineData parse_line(std::string& line){\r\n    std::vector<std::string> tokens;\r\n    std::string token;\r\n\r\n    std::istringstream token_stream(line);\r\n    char delimiter = ' ';\r\n\r\n    while (std::getline(token_stream, token, delimiter)) {\r\n        tokens.push_back(token);\r\n    }\r\n\r\n    std::map<std::string ,std::string> parameters;\r\n\r\n    for(auto it = tokens.begin() + 1;it != tokens.end(); it++ )\r\n    {\r\n        // Podział string-a na dwie części\r\n        char equal = '=';\r\n        std::string value;\r\n        std::vector<std::string> value_list;\r\n        std::istringstream value_stream(*it);\r\n        while (std::getline(value_stream , value, equal)) {\r\n            value_list.push_back(value);\r\n        }\r\n        parameters[value_list[0]] = value_list[1];\r\n    }\r\n    ParsedLineData new_line;\r\n\r\n    new_line.parameters = parameters;\r\n\r\n    new_line.element_type = get_El_type(tokens[0]);\r\n\r\n    return new_line;\r\n}\r\n\r\nElementType get_El_type(std::string& str)\r\n{\r\n    if(str == \"LOADING_RAMP\")\r\n        return  ElementType::RAMP;\r\n    else if(str == \"WORKER\")\r\n        return ElementType::WORKER;\r\n    else if(str == \"STOREHOUSE\")\r\n        return ElementType::STOREHOUSE;\r\n    else if(str == \"LINK\")\r\n        return ElementType::LINK;\r\n    else\r\n        throw std::logic_error(\"Niedopasowano typu węzła lub połączenia\");\r\n}\r\n\r\nElementType get_el_type_small(std::string& str)\r\n{\r\n    if(str == \"ramp\")\r\n        return  ElementType::RAMP;\r\n    else if(str == \"worker\")\r\n        return ElementType::WORKER;\r\n    else if(str == \"store\")\r\n        return ElementType::STOREHOUSE;\r\n    else\r\n        throw std::logic_error(\"Niedopasowano typu węzła lub połączenia\");\r\n}\r\n\r\nvoid save_factory_structure(Factory& factory, std::ostream& os)\r\n{\r\n    os<<\"\\n\";\r\n    os<<\"; == LOADING RAMPS ==\";\r\n    os<<\"\\n\";\r\n\r\n    for(auto it_r = factory.ramp_cbegin();it_r != factory.ramp_cend(); it_r++)\r\n    {\r\n        os<<\"LOADING_RAMP id=\";\r\n        os<<std::to_string(it_r->get_id());\r\n        os<<\" delivery-interval=\";\r\n        os<<std::to_string(it_r->get_delivery_interval());\r\n        os<<\"\\n\";\r\n\r\n    }\r\n\r\n    os<<\"\\n\";\r\n\r\n\r\n    os<<\"; == WORKERS ==\";\r\n    os<<\"\\n\";\r\n\r\n\r\n    for(auto it_w = factory.worker_cbegin();it_w != factory.worker_cend(); it_w++) {\r\n        os << \"WORKER id=\";\r\n        os << std::to_string(it_w->get_id());\r\n        os << \" processing-time=\";\r\n        os << std::to_string(it_w->get_processing_duration());\r\n        os << \" queue-type=\";\r\n\r\n        if (it_w->get_queue()->get_queue_type() == PackageQueueType::LIFO) {\r\n            os << \"LIFO\";\r\n        } else if (it_w->get_queue()->get_queue_type() == PackageQueueType::FIFO) {\r\n            os << \"FIFO\";\r\n        } else {\r\n            throw std::logic_error(\"Nie znaleziono odpowiedniego typu kolejki\");\r\n        }\r\n        os << \"\\n\";\r\n\r\n    }\r\n    os<<\"\\n\";\r\n    os<<\"; == STOREHOUSES ==\";\r\n    os<<\"\\n\";\r\n\r\n\r\n    for(auto it_s = factory.storehouse_cbegin();it_s != factory.storehouse_cend(); it_s++)\r\n    {\r\n        os<<\"STOREHOUSE id=\";\r\n        os<<std::to_string(it_s->get_id());\r\n        os<<\"\\n\";\r\n    }\r\n\r\n    os<<\"\\n\";\r\n    os<<\"; == LINKS ==\";\r\n    os<<\"\\n\";\r\n\r\n\r\n    for(auto it_r = factory.ramp_cbegin();it_r != factory.ramp_cend(); it_r++) {\r\n\r\n        for(auto it_2 : it_r->receiver_preferences_.Reciver_list)\r\n        {\r\n            os << \"LINK src=ramp-\";\r\n            os << std::to_string(it_r->get_id());\r\n            if(it_2.first->get_receiver_type()   == ReceiverType::STOREHOUSE)\r\n                os << \" dest=store-\";\r\n            else if(it_2.first->get_receiver_type()   == ReceiverType::WORKER)\r\n                os << \" dest=worker-\";\r\n            else\r\n                throw std::logic_error(\"Nie znaleziono odpowiedniego typu odbiorcy\");\r\n            os<<std::to_string(it_2.first->get_id());\r\n            os<<\"\\n\";\r\n        }\r\n        os<<\"\\n\";\r\n    }\r\n\r\n    for(auto it_w = factory.worker_cbegin();it_w != factory.worker_cend(); it_w++) {\r\n\r\n        for(auto it_2 : it_w->receiver_preferences_.Reciver_list)\r\n        {\r\n            os << \"LINK src=worker-\";\r\n            std::string id = std::to_string(it_w->get_id());\r\n            os << id;\r\n            if(it_2.first->get_receiver_type()        == ReceiverType::STOREHOUSE)\r\n                os << \" dest=store-\";\r\n            else if(it_2.first->get_receiver_type()   == ReceiverType::WORKER)\r\n                os << \" dest=worker-\";\r\n            else\r\n                throw std::logic_error(\"Nie znaleziono odpowiedniego typu odbiorcy\");\r\n            os<<std::to_string(it_2.first->get_id());\r\n            os<<\"\\n\";\r\n        }\r\n        os<<\"\\n\";\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// 35: Rafa (401991) Szota(401281)  Lenarczyk(402763)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/factory.cpp b/src/factory.cpp
--- a/src/factory.cpp	(revision 7a8cf0f2fd37946f75c7cfb35e50dc4fcc662300)
+++ b/src/factory.cpp	(date 1611139602896)
@@ -25,7 +25,6 @@
     assert(false);
     return Ramps.end();
 
-    Ramps.
 }
 
 NodeCollection<Ramp>::const_iterator Factory::find_ramp_by_id(ElementID id) const
@@ -434,14 +433,22 @@
     os<<"; == STOREHOUSES ==";
     os<<"\n";
 
+    std::list<NodeCollection<Storehouse>::const_iterator> Strore_house_its;
 
     for(auto it_s = factory.storehouse_cbegin();it_s != factory.storehouse_cend(); it_s++)
     {
+        Strore_house_its.push_back(it_s);
+    }
+    Strore_house_its.sort([](auto&a, auto&b){return a->get_id() < b->get_id();});
+
+    for(auto& store : Strore_house_its)
+    {
         os<<"STOREHOUSE id=";
-        os<<std::to_string(it_s->get_id());
+        os<<std::to_string(store->get_id());
         os<<"\n";
     }
 
+
     os<<"\n";
     os<<"; == LINKS ==";
     os<<"\n";
